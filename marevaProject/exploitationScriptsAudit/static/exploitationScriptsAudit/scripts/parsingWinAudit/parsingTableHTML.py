# coding: utf-8
# Auteur: D4mocl3s

from bs4 import BeautifulSoup
import string

class ParsingTableHTML():

    def __init__(self, tableHTML, listeAttributsTable, wayParsingTable):

        self.dictExtractParsing = {}

        self.tableHTML = tableHTML
        self.listeAttributsTable = listeAttributsTable
        self.wayParsingTable = wayParsingTable

    def parsing(self):

        if self.wayParsingTable == 1:

            # Création d'un itérateur sur listeAttributsTable
            listeAttributsTable_Iterator = iter(self.listeAttributsTable)
            # Affectation des valeurs sucessives de listeAttributsTable
            attribut = next(listeAttributsTable_Iterator)

            # Itération sur toutes les lignes du tableau
            for tr in self.tableHTML.find_all('tr'):

                # Itération sur toutes les colonnes du tableau
                for td in tr.find_all('td'):

                    # Si l'attribut courant de la liste d'attributs correspond au nom d'une colonne
                    if attribut in td.string:

                        print('{} : {}'.format(td.string, td.next_sibling.string))

                        attribut = attribut.replace(' ', '_')

                        if str(td.next_sibling.string).isprintable() == False:

                            self.dictExtractParsing[attribut] = ''
                        
                        else:

                            self.dictExtractParsing[attribut] = td.next_sibling.string

                        # Passage au prochain attribut de listeAttributsTable
                        # Si tous les attributs de listeAttributsTable ont été passés en revue
                        # Alors attribut vaudra -1, cela permettra de pouvoir quitter les boucles
                        attribut = next(listeAttributsTable_Iterator, -1)

                    if attribut == -1:

                        break

                if attribut == -1:

                    break
        
        elif self.wayParsingTable == 2:

            # Création d'un itérateur sur listeAttributsTable
            listeAttributsTable_Iterator = iter(self.listeAttributsTable)
            # Affectation des valeurs sucessives de listeAttributsTable
            attribut = next(listeAttributsTable_Iterator)

            # Récupération de la première ligne du tableau
            premièreLigne = self.tableHTML.find('tr')

            # Liste qui stocke les positions des colonnes relatives aux attributs
            listePositionsColonnesAttributs = []

            # Itération pour récupérer les en-têtes de colonnes présents dans la première ligne du tableau
            for positionColonne, td in enumerate(premièreLigne.find_all('td')):

                # Si l'attribut courant de la liste d'attributs correspond au nom d'une colonne
                if attribut in td.string:

                    listePositionsColonnesAttributs.append(positionColonne)

                    attribut = next(listeAttributsTable_Iterator, -1)

                    if attribut == -1:

                        break

            # Récupération des autres lignes du tableau html
            autresLignes = self.tableHTML.find_all('tr')[1:]

            # Liste qui stocke les en-têtes de colonnes présents dans la première ligne du tableau
            colonnesStringPremièreLigne = [td.string for td in premièreLigne.find_all('td')]

            # Itération sur toutes les lignes du tableau
            for i, tr in enumerate(autresLignes, start=1):

                tr = tr.find_all('td')

                # Ajout d'une ligne pour chaque enregistrement dans la future table
                self.dictExtractParsing[i] = {}

                # Itération sur les positions des colonnes relatives aux attributs
                for positionColonne in listePositionsColonnesAttributs:

                    # Si la cellule correspond à un espace
                    if tr[positionColonne].string == "\u00a0":

                        self.dictExtractParsing[i][colonnesStringPremièreLigne[positionColonne].replace(' ', '_')] = ''
                    
                    else:

                        self.dictExtractParsing[i][colonnesStringPremièreLigne[positionColonne].replace(' ', '_')] = tr[positionColonne].string

                    print('{} : {}'.format(colonnesStringPremièreLigne[positionColonne].replace(' ', '_'), tr[positionColonne].string))
                    
                print('')

if __name__ == '__main__':

    with open(r'D:\Documents\Programmation\Python\Projet_Solo\Django_Projet_Mareva\marevaProject\exploitationScriptsAudit\static\exploitationScriptsAudit\scripts\parsingWinAudit\table.html', 'r') as f:

        html = f.read()

    soup = BeautifulSoup(html, 'html.parser')

    tableHTML = soup.find('table')
    wayParsingTable = 1
    listeAttributsTable = ['Total Memory', 'Free Memory', 'Maximum Swap File', 'Free Swap File']

    table = ParsingTableHTML(tableHTML, listeAttributsTable, wayParsingTable)

    table.parsing()

    print(table.dictExtractParsing)

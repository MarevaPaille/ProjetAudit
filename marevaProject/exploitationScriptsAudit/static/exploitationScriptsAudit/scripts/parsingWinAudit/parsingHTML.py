# coding: utf-8
# Auteur: D4mocl3s

from bs4 import BeautifulSoup
from .parsingTableHTML import ParsingTableHTML
# from parsingTableHTML import ParsingTableHTML

class ParsingHTML():

    def __init__(self, html):

        self.html = BeautifulSoup(html, 'html.parser')
        self.dictExtractParsing = {}

    def parsing(self):

        """ Méthode permettant de parser le fichier html du script WinAudit """

        # Dictionnaire qui spécifie les éléments à récupérer sur lequel s'appuie le script 
        dictSettingsParsing = {
            
            'Résumé du Système': {

                'tableNameBDD': 'Ordinateur',
                'tableAttributsHTML': [
                    
                    'Computer Name', 
                    'Domain Name', 
                    'Operating System', 
                    'Manufacturer', 
                    'Model', 
                    'Serial Number', 
                    'Processor Description', 
                    'Total Memory', 
                    'Total Hard Drive', 
                    'BIOS Version', 
                    'User Account'
                    
                ],
                'wayParsingHTML': 1,
                'wayParsingTable': 1
            },

            'Installed Programs': {

                'tableNameBDD': 'Programme_Installe',
                'tableAttributsHTML': [
                    
                    'Name', 
                    'Vendor', 
                    'Version', 
                    'Install Location', 
                    'Install Source'
                    
                ],
                'wayParsingHTML': 2,
                'wayParsingTable': 1
            },

            'Système d\'exploitation': {

                'tableNameBDD': 'Systeme_Exploitation',
                'tableAttributsHTML': [
                    
                    'Name', 
                    'Edition', 
                    'Install Date',
                    'Registered Owner',
                    'Operating System Language',
                    'Number of Bits'
                    
                ],
                'wayParsingHTML': 1,
                'wayParsingTable': 1
            },

            'Groups': {

                'tableNameBDD': 'Groupe',
                'tableAttributsHTML': [
                    
                    'Group Type', 
                    'Group Name', 
                    'Comment'
                    
                ],
                'wayParsingHTML': 2,
                'wayParsingTable': 1
            },

            'Users': {

                'tableNameBDD': 'Utilisateur',
                'tableAttributsHTML': [
                    
                    'User Account', 
                    'Account Status', 
                    'Local Groups',
                    'Last Logon',
                    'Last Logoff',
                    'Password Age',
                    'Password Expired'
                    
                ],
                'wayParsingHTML': 2,
                'wayParsingTable': 1
            },

            'Tâches planifiées': {

                'tableNameBDD': 'Tache_Planifiee',
                'tableAttributsHTML': [
                    
                    'Task Name', 
                    'Status', 
                    'Run Command'
                    
                ],
                'wayParsingHTML': 2,
                'wayParsingTable': 1
            },

            'BIOS Details': {

                'tableNameBDD': 'Version_Bios',
                'tableAttributsHTML': [
                    
                    'SMBIOS Version', 
                    'BIOS Vendor', 
                    'BIOS Version', 
                    'ROM Size'
                    
                ],
                'wayParsingHTML': 1,
                'wayParsingTable': 1
            },

            'Mémoire': {

                'tableNameBDD': 'Memoire',
                'tableAttributsHTML': [
                    
                    'Total Memory', 
                    'Free Memory', 
                    'Maximum Swap File', 
                    'Free Swap File'
                    
                ],
                'wayParsingHTML': 1,
                'wayParsingTable': 1
            },

            'Disques physiques': {

                'tableNameBDD': 'Disque_Physique',
                'tableAttributsHTML': [
                    
                    'Disk Number', 
                    'Model', 
                    'Serial Number', 
                    'Capacity'
                    
                ],
                'wayParsingHTML': 2,
                'wayParsingTable': 1
            },

            'Programmes de démarrage': {

                'tableNameBDD': 'Programme_Demarrage',
                'tableAttributsHTML': [
                    
                    'Program Name', 
                    'Settings Folder', 
                    'Command'
                    
                ],
                'wayParsingHTML': 1,
                'wayParsingTable': 2
            }    
        }

        # Création d'un itérateur sur les pairs de clé/valeur de dictSettingsParsing
        dictSettingsParsing_Items_Iterator = iter(dictSettingsParsing.items())
        # Affectation des pairs de clé/valeur sucessives de dictSettingsParsing
        dictSettingsParsing_Item = next(dictSettingsParsing_Items_Iterator)

        # Itération sur chaque balise <center> du fichier html
        for center in self.html.find_all('center'):

            # stringCenter --> Chaîne de caractères recherchée dans une balise <center> du code html
            # dictStringCenter --> Dictionnaire possédant les paramètres correspondant à stringCenter
            # /!\ Attention à bien remplir dans dictSettingsParsing les clés stringCenter dans l'ordre d'apparition des noms de balises <center> recherchées /!\
            stringCenter, dictStringCenter = dictSettingsParsing_Item

            if dictStringCenter['wayParsingHTML'] == 1:
    
                # Si stringCenter correspond à la valeur d'une balise <center> du code html
                if stringCenter in center.string:
    
                    # Récupération du tableau de la balise <table> qui suit la balise <center>
                    tableHTML = center.next_sibling.next_sibling

                    # Récupération du nom de la future table de la BDD qui accueuillera les données parsées
                    tableNameBDD = dictStringCenter['tableNameBDD']

                    print('\n----{}----\n'.format(tableNameBDD))

                    # Liste des attributs auxquels il faudra récupérer les valeurs corespondantes
                    # /!\ Attention à bien remplir dans dictSettingsParsing la liste dans l'ordre d'apparition des attributs /!\
                    listeAttributsTable = dictStringCenter['tableAttributsHTML']

                    # Récupération de la façon de parser la table
                    wayParsingTable = dictStringCenter['wayParsingTable']

                    # Instanciation d'un objet tableHTML
                    tableHTML = ParsingTableHTML(tableHTML, listeAttributsTable, wayParsingTable)
                    tableHTML.parsing()

                    self.dictExtractParsing[tableNameBDD] = tableHTML.dictExtractParsing

                    # Prochain item de dictSettingsParsing
                    dictSettingsParsing_Item = next(dictSettingsParsing_Items_Iterator, -1)
                
                if dictSettingsParsing_Item == -1:

                    break

            elif dictStringCenter['wayParsingHTML'] == 2:

                if stringCenter in center.string:

                    # Récupération du nom de la future table de la BDD qui accueuillera les données parsées
                    tableNameBDD = dictStringCenter['tableNameBDD']

                    self.dictExtractParsing[tableNameBDD] = {}

                    print('\n----{}----\n'.format(tableNameBDD))

                    # Liste des attributs auxquels il faudra récupérer les valeurs corespondantes
                    # /!\ Attention à bien remplir dans dictSettingsParsing la liste dans l'ordre d'apparition des attributs /!\
                    listeAttributsTable = dictStringCenter['tableAttributsHTML']

                    wayParsingTable = dictStringCenter['wayParsingTable']

                    numéroEnregistrementBDD = 1

                    # Récupération de la balise soeur de la balise <center>
                    baliseSoeur = center.next_sibling

                    # Répéter jusqu'à la prochaine balise center
                    while baliseSoeur.name != 'center':

                        # Si la balise courante est une balise <table>
                        if baliseSoeur.name == 'table':

                            tableHTML = ParsingTableHTML(baliseSoeur, listeAttributsTable, wayParsingTable)
                            tableHTML.parsing()

                            self.dictExtractParsing[tableNameBDD][numéroEnregistrementBDD] = tableHTML.dictExtractParsing

                            numéroEnregistrementBDD += 1

                            print('')

                        # Récupération de la balise soeur de la balise courante
                        baliseSoeur = baliseSoeur.next_sibling

                    # Prochain item de dictSettingsParsing
                    dictSettingsParsing_Item = next(dictSettingsParsing_Items_Iterator, -1)
                
                if dictSettingsParsing_Item == -1:

                    break

        return self.dictExtractParsing

if __name__ == '__main__':

    import json

    with open(r'C:\Users\Marèva\Documents\testProjet\marevaProject\exploitationScriptsAudit\static\exploitationScriptsAudit\export\UCC85B76E7773D.html', 'r') as f:

        html = f.read()

    html = ParsingHTML(html)
    html.parsing()

    print(html.dictExtractParsing)

    # with open(r'C:\Users\Simon\Downloads\extract.json', 'w') as outfile:

    #     json.dump(html.dictExtractParsing, outfile)
